import math

###################################### Functions ################################################

# use previously calculated Magic Ratios™ to increment given values in the Minecraft coordinate system
def trigIterate(x, z, theta, cosinemagic, sinemagic):
    x = x + sinemagic
    z = z - cosinemagic
    return(x, z)

# calculate distance from point A to point B
def distance(x_A, z_A, x_B, z_B):
    return math.sqrt((x_A-x_B)**2 + (z_A-z_B)**2)

# parse generated F3+C game output 
def parseCmd(cmd: str):
    data = cmd[42:].split(" ")
    data = [float(i) for i in data]
    data[3] = round((data[3] + 180) % 360, 2)
    del data[4], data[1]
    return data

############################## Magic Ratios™ and other misc #####################################

# prompt the user for cmd's
cmd = input("Enter the first command generated by MC: ")
data1 = parseCmd(cmd)
cmd = input("Enter the second command generated by MC: ")
data2 = parseCmd(cmd)


# assign readings to variables
x_A, z_A = data1[0], data1[1]
theta_A = data1[2]
x_B, z_B = data2[0], data2[1]
theta_B = data2[2]


# Magic Ratios™ fuckery (Magic Ratios™ are the rates at which the coordinates will change when incremented)
theta_A, theta_B = math.radians(theta_A), math.radians(theta_B)
cos_A, sin_A = math.cos(theta_A), math.sin(theta_A)
cos_B, sin_B = math.cos(theta_B), math.sin(theta_B)


############################# Main function loop ####################################

# Main loop; Increments both coordinates by the Magic Ratios™
# (essentially simulating following the angle at which the Ender Eyes were thrown,
# until the paths cross and are at their closest, where the function breaks and spews out the final coordinates.
prev_dist = dist = 1000000
while True:
    incr = dist > prev_dist
    print(f"{round(x_A)}\t{round(z_A)}\t{round(x_B)}\t{round(z_B)}\t{round(dist)}\t{incr}")
    
    x_A, z_A = trigIterate(x_A, z_A, theta_A, cos_A, sin_A)
    x_B, z_B = trigIterate(x_B, z_B, theta_B, cos_B, sin_B)
    
    prev_dist = dist
    dist = distance(x_A, z_A, x_B, z_B)

    if incr:
        print(f"XYZ Coordinates: [{round(x_A)} ~ {round(z_A)}] Accuracy: {round(dist)}m")
        break

input("\nPress enter to exit...")